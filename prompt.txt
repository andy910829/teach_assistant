è«‹è©•åˆ†ä»¥ä¸‹å­¸ç”Ÿçš„ä½œæ¥­ï¼š

            å­¸è™Ÿï¼š114C73032
            å§“åï¼šç‹ç•Œæ£ 

            æª”æ¡ˆçµæ§‹:
            ğŸ“ 114C73032_w13/
ğŸ“„ 114C73032_w13.zip
ğŸ“„ 114C73032_w13\main.c
ğŸ“„ 114C73032_w13\main.h
ğŸ“„ 114C73032_w13\makefile
ğŸ“„ 114C73032_w13\queue.c
ğŸ“„ 114C73032_w13\queue.h
ğŸ“„ 114C73032_w13\space.c
ğŸ“„ 114C73032_w13\space.h

            ç¨‹å¼ç¢¼ï¼š
            
C æª”æ¡ˆï¼š
#include "main.h"
#include "queue.h"
#include "space.h"

int main(void)
{
    tQueue *queue = NULL;
    int operation = 0;

    tQueueNode *target_node = NULL;
    int id = 0, score = 0, ret = 0;

    queue = createQueue();
    // é€™é‚Šæœƒæ¥ å‡½æ•¸å‚³å‡ºä¾†çš„ç©ºé–“é–€ç‰Œ

    while (1)
    {

        printf("\nWhich type you are going to operate? \n");
        printf("1. Add a small item\n");
        printf("2. Add a big item\n");
        printf("3. Remove a small item with a specific Id\n");
        printf("4. Remove a big item with a specific Id\n");

        scanf("%d", &operation);
        //
        if (operation == 1 || operation == 2)
        {
            printf("  Enter id: \n");
            scanf("%d", &id);
            printf(" Enter score: \n");
            scanf("%d" ,&score);

            ret = enqueue_node(queue, id, score, (operation == 1 ? TYPE_SMALL : TYPE_LARGE));
            // è‹¥ç­‰æ–¼ 1 å‰‡è³‡æ–™æ˜¯å°è³‡æ–™ , å¦å‰‡æ˜¯å¤§è³‡æ–™

            if (ret == 0)
            {
                printf("    Cannot enter to the queue\n");
            }

            print_buffer_status();
            // å°å‡º ç›®å‰ buffer ç‹€æ…‹
        }
        else if (operation == 3 || operation == 4)
        {
            printf("  Enter an ID to remove ");

            scanf("%d", &id);

            target_node = find_target_node(queue, id, (operation == 3 ? TYPE_SMALL : TYPE_LARGE));
            // å¦‚æœ è¼¸å…¥ç­‰æ–¼3æ™‚ å‰‡å‚³å…¥TYPE_SMALL å¦å‰‡ å‚³å…¥ TYPE_LARGE
            // å¾Œé¢æ˜¯é€™å€‹å‡½æ•¸è¦è¼¸å…¥çš„åƒæ•¸

            if (target_node == NULL)
            {
                printf("    Cannot find the target node \n");
            }

            else

            {
                dequeue_node(queue, target_node, (operation == 3 ? TYPE_SMALL : TYPE_LARGE));
                // å¦‚æœ è¼¸å…¥ç­‰æ–¼3æ™‚ å‰‡å‚³å…¥TYPE_SMALL å¦å‰‡ å‚³å…¥ TYPE_LARGE
            }
            print_buffer_status();
        }

        else

        {
            printf("    No such operation \n");
        }
        print_queue(queue);
    }
}

---
#include "queue.h"
#include "space.h"

/*é€™é‚Šæ˜¯åœ¨åšç”Ÿç”¢ç©ºé–“*/
tQueue *createQueue(void) // é€™é‚Šå°±æ˜¯å‡ºä¸€å€‹ç®¡ç†çš„é ­
{
    tQueue *queue;
    queue = (tQueue *)malloc(sizeof(tQueue));
    //  malloc å»ºç«‹ä¸€å€‹ é ­çš„ç®¡ç†æˆ¿é–“
    //  ç”Ÿç”¢ä¸­å¿ƒå»ºç«‹

    if (queue != NULL) // å¦‚æœå‰µå¥½,å°±è£¡é¢åˆå§‹åŒ–
    {
        queue->front = NULL;
        queue->rear = NULL;
        queue->count = 0;

        return queue;
    }
    else
    {
        printf("The Queue Build is fail");
        return NULL;
    }
}

/*åŠ å…¥åºåˆ— é ˜æ–™ å…¥åº«*/
int enqueue_node(tQueue *queue, int id, int score, int data_type)
{

    tQueueNode* node = (tQueueNode*)malloc(sizeof(tQueueNode));     // å…ˆå‰µä¸€å€‹å°æ‡‰çš„ç¯€é»å–è²¨
    if(node == NULL)
    {
        printf("Error from enqueue_node function \n");
        printf("The node create is fail !! \n");
        return 0;
    }


    void* content = NULL;    // è¬ç”¨å­—å…ƒ,è¬ç”¨ç©ºé–“ (å¯¦åšåœ¨è½‰æ›)
    int mem_location = -1;     // é€™å€‹æ˜¯åœ¨æ¨™ç¤ºå“ªæ ¼ç©ºé–“å¯ä»¥è¢«åšä½¿ç”¨
    int from_small = 0;

    /*å›å‚³è£å¥½å…§å®¹çš„æ±è¥¿èˆ‡å°æ‡‰æ±è¥¿çš„é–€ç‰Œ*/
    our_malloc(data_type, &content, &mem_location,&from_small);
    // ** &ç›´æ¥ç¶ newptr èˆ‡ å– mem_location

    if (content == NULL || mem_location == -1)
    {
        printf("    Enqueue False!!! \n");
        return 0;
    }

    else    /*é€²è¡Œå°æ‡‰å¯¦åš*/
    {
        // é€™é‚Šå…ˆå°‡node æˆ¿é–“ä¸­çš„ content æ”¾å…¥å°æ‡‰çš„content
        node->type = data_type;

        if (node->type == TYPE_SMALL) // é€™é‚Šæ˜¯å°buffer ç©ºé–“çš„è³‡æ–™çµæ§‹é€²è¡Œæ“ä½œ
        {
            tQueueSmall* item = (tQueueSmall*)content;
    
            /*é€™æ®µæ˜¯åœ¨è™•ç†bufferè£¡é¢çš„å…§å®¹*/
            item->id = id;
            item->location = mem_location;
            item->score = score;

            /*æ¥ä¸Šbuffer*/
            node->content = content;

        }

        if(data_type == TYPE_LARGE)
        {
            tQueueLarge* item = (tQueueLarge*)content;

            /*é€™æ®µæ˜¯åœ¨è™•ç†bufferè£¡é¢çš„å…§å®¹*/
            item->id = id;
            item->location = mem_location;
            item->score[0] = score;
            // æš«æ™‚å¯«0,ä¹‹å¾Œè¦å†ä¿®æ”¹

             /*æ¥ä¸Šbuffer*/
            node->content = content;
            node->from_small = from_small; //use the small area?

        }


        /*éˆçµä¸²åˆ—å¯¦åš*/
        if(queue->count ==0)
        {
            queue->front = node;
            queue->rear = node;
            node->next = NULL;
            node->prev = NULL; 
        }
        else /*é€™é‚Šæ˜¯ä»¥æ–°å»ºçš„nodeç‚ºä¸»*/
        {
            node->prev = queue->rear;
            node->next = NULL;
            queue->rear->next =node;
            // == ä¸Šä¸€å€‹node çš„ next æ¥åˆ°ç›®å‰çš„node
            queue->rear = node;
            // ç›®å‰çš„å°¾æ›´æ–°æˆç¾åœ¨æ–°å‰µçš„node
        }
        queue->count++;
        return 1;
    }
}

/*ç§»é™¤åºåˆ— node*/
void dequeue_node(tQueue *queue, tQueueNode *target, int data_type)
{
    /* å®‰å…¨é‚Šç•Œæª¢æŸ¥*/
    if (queue->count == 0 || target == NULL)
    {
        return;
    }

    else if (queue->count == 1) // æœ€å¾Œä¸€å€‹ç¯€é» else if ->å…¨éƒ¨éƒ½æ˜¯åœ¨è™•ç†ä¾‹å¤–æƒ…æ³
    {
        queue->front = NULL; // å°‡é ­å°¾ç›´æ¥æŒ‡ç©º
        queue->rear = NULL;
    }

    else if (target == queue->front && queue->front != NULL) // ç›®æ¨™çš„è¨˜æ†¶é«”ä½ç½®èˆ‡é ­çš„è¨˜æ†¶é«”ä½ç½®å–”ä¸€æ¨£
    {
        queue->front = target->next; // å°‡é ­æ›´æ–°æˆç›®æ¨™ç¯€é»çš„ä¸‹ä¸€å€‹
        queue->front->prev = NULL;
    }

    else if (target == queue->rear && queue->rear != NULL)
    {
        queue->rear = target->prev;
        // å°‡å°¾å·´æ›´æ–°æˆ ç›®æ¨™ç¯€é»çš„ä¸Šä¸€å€‹
        queue->rear->next = NULL; // å°‡å°¾å·´çš„ä¸‹å€‹ç¯€é» æ›´æ–°æˆç©ºçš„
    }

    else // ä¸­é–“
    {
        target->prev->next = target->next; // å°‡ä¸Šä¸€å€‹ç¯€é»çš„ ä¸‹ä¸€å€‹ç¯€é» é€£æ¥çš„å°è±¡æ›´æ–°æˆ ä¸‹ä¸€å€‹
        target->next->prev = target->prev;
    }

    /*ç”¨æ–¼æ¸…ç©º éœæ…‹ç©ºé–“ä¸­çš„å…§å®¹*/
    int location = 0;
    if (data_type == TYPE_SMALL)
    {
        tQueueSmall* item = (tQueueSmall*)target->content;
        // æŒ‡åˆ°å°ç©ºé–“çš„å…§å®¹ç‰©
        location = item->location;
        our_free(TYPE_SMALL , location , target->from_small);

    }
    else if(data_type == TYPE_LARGE && target->from_small==1)
    {
        tQueueSmall* item = (tQueueSmall*)target->content;
        location = item->location;
        our_free(TYPE_LARGE,location,target->from_small);
    }
    else
    {
        tQueueLarge* item = (tQueueLarge*) target->content;
        location = item->location;
        our_free(TYPE_LARGE,location,target->from_small);
    }

    free(target);
    queue->count--; // æ¸›æ‰ä¸€å€‹
}

/*æ‰¾ç¯€é»*/
tQueueNode *find_target_node(tQueue *queue, int id, int data_type)
{
    if (queue == NULL || queue->count == 0)
    {
        return NULL;
    }

    tQueueNode *currentNode = queue->front; // å…ˆå¾é ­ é–‹å§‹æœå°‹
    if (currentNode==NULL)
    {
        printf("Error from find_target_node \n ");
        printf("The queue front is empty !!");

        return NULL;
    }

    int i = 0;
    for (i; i < queue->count; i++)
    {
        if(currentNode->type != data_type) //å…ˆç¨½æŸ¥è³‡æ–™é¡å‹
        {
            currentNode = currentNode->next;
            continue;
        }
        else
        {
            tQueueLarge* item = (tQueueLarge*)currentNode->content;
            if (item->id == id)
            {
                return currentNode;
                // å›å‚³ç›®å‰node çš„ è¨˜æ†¶é«”é–€ç‰Œ
            }
        }

        currentNode = currentNode->next;
       
    }
    return NULL;
}

void print_queue(tQueue *queue)
{
    int i = 0 , id = 0 , score = 0 , location = 0 ;
    char nodetype = '0';

    tQueueNode *target = queue->front;

    printf(" type mixed queue: \n "); //å°å‡º content å…§å®¹

    for (i; i < queue->count; i++)
    {
        if(target->type == TYPE_SMALL)
        {
            tQueueSmall* item = (tQueueSmall*)target->content;
            // æŠ½å»å°æ‡‰ç¯€é»çš„ ç©ºé–“å…§å®¹ç‰©
            id = item->id;
            score = item->score;
            location = item->location;
            nodetype = 'S'; //samll
        }
        else if (target->type == TYPE_LARGE && target->from_small == 1)
        {
            tQueueLarge* item = (tQueueLarge*)target->content;
            id = item->id;
            score = item->score[0];
            location = item->location;
            nodetype = 'M'; //mix
        }
        else
        {
            tQueueLarge* item = (tQueueLarge*)target->content;
            id = item->id;
            score = item->score[0];
            location = item->location;
            nodetype = 'L';
            
        }
        printf("\n");

        printf("%d,%d ,%c,%d \n",id,score,nodetype,location);

        target = target->next; // æ›´æ–°è‡³ä¸‹å€‹ç¯€é»çš„ä½ç½®

        printf("\n");
    }

     printf("\n");
}

   


---
#include "space.h"

/* space å‡½å¼å…§å»ºåƒæ•¸*/
unsigned char buffer[(NUM_SMALL_BYTE_BUF * SMALL_ELEMENT_SIZE) + (NUM_LARGE_BYTE_BUF * LARGE_ELEMENT_SIZE)];
// ç¸½å…± 768 byte ç©ºé–“
unsigned char byte_large_buf_mask = 0; // é€™é‚Šæ˜¯é¢ç½©
unsigned char byte_small_buf_mask = 0;
/* space å‡½å¼å…§å»ºåƒæ•¸*/


void print_buffer_status(void)
{
    int i = 0;
    unsigned char mask = 0x80;
    // 8 bit å¤§å°
    printf(" The small buffer mask  : ");
    for (i; i < 8; i++)
    {
       
        printf("%d" ,(byte_small_buf_mask & mask) >> (7 - i)); 

        mask = mask >> 1;
        // å¾€å¾Œæ¨ä¸€å€‹ ä¸¦ä¸”æ›´æ–°é¢ç½©çš„ä½ç½®
    }
    printf("\n");
    printf(" The larger buffer mask :");

    /*å› ç‚ºæ˜¯åœ¨åŒä¸€éš»ç¨‹å¼ä¸­,è«‹è¨˜å¾—æŠŠ i å’Œ mask é‚„åŸæˆåŸæœ¬çš„æ¨£å­*/
    mask = 0x80;
    for (i=0; i < 8; i++)
    {
       
        printf("%d" , (byte_large_buf_mask & mask) >> (7 - i));
        // å¾€å¾Œæ¨å‡ºå»
        mask = mask >> 1;
        // å¾€å¾Œæ¨ä¸€å€‹ ä¸¦ä¸”æ›´æ–°é¢ç½©çš„ä½ç½®
    }

    printf("\n");
}

void our_malloc(int type, void** target, int* mem_location , int* from_small)
// é€™é‚Šè¦å¹«å¿™æ‰¾ä½ç½®
{
    int index = 0;

    if (type == TYPE_SMALL)
    {
        index = test_single_location();
        if(index == -1)
        {
            printf("The error from our_malloc \n");
            printf("The sapce is full \n");
            *target = NULL;
            *mem_location = -1;
            return;
        }
        else
        {
            *target = (void*) &(buffer[index*SMALL_ELEMENT_SIZE]);
            /* é€™é‚Šæ˜¯åœ¨åšä¸‰ä»¶äº‹
            / å…ˆæŒ‡å®šç›®å‰bufferçš„è³‡æ–™å‹æ…‹æ˜¯è¬ç”¨çš„ 
            /  &->å°å¾Œé¢çš„() è£¡é¢ç®—å‡ºä¾†çš„ empty queue space é€²è¡Œå–å€
            /  [index * SMALL_ELEMENT_SIZE] é€²è¡Œæ¨™æº–ä½ç§»è¨ˆç®—
            */
            set_single_bit(index);
            *mem_location = index; // å°‡mem_location æŒ‡æ¨™å…§å®¹å¡«å…¥ index
            
        }

    }

    if(type == TYPE_LARGE)
    {
        index = test_dual_location();
        if(index != -1)
        {
            *from_small = 0;
            *target = (void*) &(buffer[LARGE_START + (index * LARGE_ELEMENT_SIZE)]);
         /* é€™é‚Šæ˜¯åœ¨åšä¸‰ä»¶äº‹
         / å…ˆæŒ‡å®šç›®å‰bufferçš„è³‡æ–™å‹æ…‹æ˜¯è¬ç”¨çš„ 
         /  &->å°å¾Œé¢çš„() è£¡é¢ç®—å‡ºä¾†çš„ empty queue space é€²è¡Œå–å€
         /  [index * SMALL_ELEMENT_SIZE] é€²è¡Œæ¨™æº–ä½ç§»è¨ˆç®—
        */
             set_dual_bit(index);
            *mem_location = index; // å°‡mem_location æŒ‡æ¨™å…§å®¹å¡«å…¥ index
        }
        else // use the small space
        {
            index = find_two_small_location();
            *from_small = 1;

            if (index == -1)
            {
                printf("The error from our_malloc \n");
                printf("The sapce is full \n");
                *from_small = 0;
                *target = NULL;
                *mem_location = -1;
                return;
            } 
                          
            *target = (void*)  &(buffer[index*SMALL_ELEMENT_SIZE]); // é€™é‚Šå› ç‚ºæ˜¯small element çš„å€åŸŸ,å› æ­¤è¦åœ¨å¾Œé¢ä¹˜ SMALL_ELEMENT_SIZE
             set_single_bit(index);
             set_single_bit(index + 1);

            *mem_location = index;
        }
    }
}

int test_single_location(void) // large space
{
    int i = 0;
    unsigned char mask = 0x01; // é€™é‚Šè£½ä½œ mask é€²è¡Œæ¯”å°

    for (i; i < NUM_SMALL_BYTE_BUF; i++) // éæ­·å°‹æ‰¾ index
    {
        if((byte_small_buf_mask & mask) == 0)
        {
            return i;
        }

        else
        {
            mask = mask << 1; // å‘å³ç§»ä¸€ä½ ,æ‰¾ä¸‹å€‹ä½ç½®
                              // mask å°±å¦‚åŒæ‰‹é›»ç­’ å¦‚æœ 00000001 æœ‰ç©ºçš„ å°±å›å‚³
                              // å¦‚æœæ²’æœ‰ å°± å¾€å³æ¨ 00000010 (ä¹Ÿå°±æ˜¯å°‡mask å¾€å³æ¨)
        }
    }

    return -1;
}


void set_single_bit(int location) // é€™é‚Šç›®å‰æ”¹æ›´æ–° å°é¢ç½©

{
    unsigned char mask = 0x01; // å¾æœ€å³é‚Šçš„ bit é–‹å§‹
    mask = mask << location;  // å°‡1å¾€å·¦æ¨å¹¾æ¬¡æ‰æœƒæˆç‚ºæˆ‘çš„æ–°çš„mask
    byte_small_buf_mask = byte_small_buf_mask | mask;
    //  é€™é‚Šç”¨ä¾†æ›´æ–° byte_buf_mask -> ä¹Ÿå°±æ˜¯åæ‡‰æœ‰å“ªå¹¾å€‹åœ°æ–¹å·²ç¶“è¢«ä½”äº†
}

int test_dual_location()
{
    int i = 0;
    unsigned char mask = 0x03; // é€™é‚Šè£½ä½œ mask é€²è¡Œæ¯”å°
                               // 3 = 00000011

    for (i; i < NUM_LARGE_BYTE_BUF - 1; i++) // å› ç‚ºæœ€çµ‚é» 7 ,è€Œä¸” maskæ˜¯å…©å€‹ ,å› æ­¤è¦è¨­å®šåœ¨6
    {
        if ((byte_large_buf_mask & mask) == 0) // é€™é‚Šçš„ byte buf mask æ˜¯ä¸€å€‹å›ºå®šç©ºé–“
                                              // è‹¥ç‚ºç©º å°±å›å‚³å°æ‡‰ç©ºé–“çš„indexå€¼
        {
            return i; // åªèƒ½å›å‚³ä¸€å€‹æ•¸å­— cèªè¨€ åªèƒ½å›å‚³ä¸€å€‹
        }

        else
        {
            mask = mask << 1; // å‘å·¦ç§»ä¸€ä½ ,æ‰¾ä¸‹å€‹ä½ç½®
                              // mask å°±å¦‚åŒæ‰‹é›»ç­’ å¦‚æœ 00000001 æœ‰ç©ºçš„ å°±å›å‚³
                              // å¦‚æœæ²’æœ‰ å°± å¾€å³æ¨ 00000010
        }
    }

    return -1;
}

int find_two_small_location(void)
{
    int i = 0;
    unsigned char mask = 0x03;
    
    for(i=0 ; i < NUM_SMALL_BYTE_BUF;i++) //é€™é‚Šæ˜¯æƒå°å–®å…ƒå€
    {
        if ((byte_small_buf_mask & mask) == 0)
        {
            return i;
        }
        else 
        {
            mask = mask << 1;
        }
    }

    return -1; // The space is all empty
}



void set_dual_bit(int location)
{
    unsigned char mask = 0x03;

    mask = mask << location; // çœŸå›  mask å¿˜è¨˜åç§»

    byte_large_buf_mask = byte_large_buf_mask | mask;
    //  é€™é‚Šç”¨ä¾†æ›´æ–° byte_buf_mask -> ä¹Ÿå°±æ˜¯åæ‡‰æœ‰å“ªå¹¾å€‹åœ°æ–¹å·²ç¶“è¢«ä½”äº†
    // | = 0 1 =11
}

void clear_single_bit(int location)
{

    byte_small_buf_mask &= ~(1 << location);
    //  é€™é‚Šç”¨ä¾†æ›´æ–° byte_buf_mask -> ä¹Ÿå°±æ˜¯åæ‡‰æœ‰å“ªå¹¾å€‹åœ°æ–¹å·²ç¶“è¢«ä½”äº†
    // a &= b a = a&b
    // a += b a = a+b
    // "~" {0 -> 1 ; 1-> 0} //Reverse
}

void clear_dual_bit(int location)
{
    byte_large_buf_mask &= ~(0x03 << location);
    //  é€™é‚Šç”¨ä¾†æ›´æ–° byte_buf_mask -> ä¹Ÿå°±æ˜¯åæ‡‰æœ‰å“ªå¹¾å€‹åœ°æ–¹å·²ç¶“è¢«ä½”äº†
}

void our_free(int type, int mem_location,int from_small)
{
    if (mem_location < 0)
    {
        return;
    }

    if (type == TYPE_SMALL)
    {
        clear_single_bit(mem_location);
    }

    else if(type == TYPE_LARGE && from_small ==1)
    {
        clear_dual_bit(mem_location);
    }
    else
    {
        clear_dual_bit(mem_location);
    }
}


æ¨™é ­æª”ï¼š
#ifndef __MAIN__
#define __MAIN__

#include <stdio.h>
#include <stdlib.h>

#define TYPE_SMALL              0
#define TYPE_LARGE              1

// é€™é‚Š def æ–‡æœ¬ æ˜¯ç”¨å·¨é›†çš„æ–¹å¼ å¼„

#endif
---
#ifndef __QUEUE__
#define __QUEUE__


typedef struct type_small
{
    int id;
    int location;
    int score;

}tQueueSmall;


typedef struct type_large /* é€™ä¸€å€‹ è³‡æ–™çµæ§‹æ˜¯çµ¦ bufferç”¨çš„ */
{
    int id;
    int location;
    int score[8];
    
}tQueueLarge;


typedef struct node_info /* é€™ä¸€å€‹ è³‡æ–™çµæ§‹æ˜¯çµ¦ bufferç”¨çš„ */
{
    int type;
    void* content; // é€™é‚Šæ˜¯è¬ç”¨å­—å…ƒ,æŒ‡å‘å°æ‡‰çš„queue
    int from_small;
    struct node_info* next;
    struct node_info* prev;

}tQueueNode;




typedef struct
{
    tQueueNode *front;
    tQueueNode *rear;
    int count;

} tQueue;

/*The function*/
tQueue *createQueue(void);

int enqueue_node(tQueue *queue, int id, int score, int data_type);

void dequeue_node(tQueue *queue, tQueueNode *target, int data_type);

tQueueNode *find_target_node(tQueue *queue, int id, int data_type);

void print_queue(tQueue *queue);

#endif
---
#ifndef __SPACE__
#define __SPACE__

#include "main.h" // code è£¡é¢æœ‰ç”¨åˆ° ä¸»å‡½å¼çš„è®Šæ•¸

#define NUM_SMALL_BYTE_BUF 8
// 8 bit å¤§å° æˆ‘çš„é¢ç½©
#define NUM_LARGE_BYTE_BUF 8

#define SMALL_ELEMENT_SIZE 32
// ä¸€å€‹å°ç©ºé–“ 4å€‹BYTE
#define LARGE_ELEMENT_SIZE 64
// ä¸€å€‹å¤§ç©ºé–“ 8å€‹byte

#define LARGE_START (NUM_SMALL_BYTE_BUF * SMALL_ELEMENT_SIZE)
// é€™é‚Šè¦å…ˆå°‡small ç¸½å€åŸŸç®—å‡º,ä¸¦åŸºæ–¼æ­¤å€åŸŸå¾€ä¸Šç–ŠåŠ 

void print_buffer_status(void);
void our_malloc(int type, void **target, int *mem_location , int* from_small);
void our_free(int type, int mem_location,int from_small);
int test_single_location();
void set_single_bit(int location);
int test_dual_location();
int find_two_small_location(void);
void set_dual_bit(int location);
void clear_single_bit(int location);
void clear_dual_bit(int location);

#endif

Makefile æª”æ¡ˆï¼š
æª”æ¡ˆï¼š114C73032_w13\makefile
å…§å®¹ï¼š
CC = gcc


OBJ = space.o queue.o main.o
EXE = run.exe

all: $(EXE)
.c.o: ; $(CC) -c $*.c

$(EXE): $(OBJ)
	$(CC) -o $@ $(OBJ)

clean:
	del /f /q $(EXE) $(OBJ)



            è©•åˆ†æ¨™æº–ï¼š
            ä½ æ˜¯ä¸€ä½ç¶“é©—è±å¯Œçš„ C èªè¨€èª²ç¨‹åŠ©æ•™ã€‚ä½ çš„ä»»å‹™æ˜¯è©•åˆ†å­¸ç”Ÿæäº¤çš„ç¨‹å¼ç¢¼ï¼Œä¸¦**å‹™å¿…ä½¿ç”¨æä¾›çš„å·¥å…·**ä¾†åŸ·è¡Œè§£å£“ç¸®èˆ‡å¯«å…¥è©•åˆ†å ±å‘Šçš„å‹•ä½œã€‚

### **ã€å·¥å…·ä½¿ç”¨æŒ‡å— (é‡è¦)ã€‘**
ä½ æ“æœ‰ä»¥ä¸‹å·¥å…·ï¼Œè«‹åœ¨é©ç•¶çš„æ™‚æ©Ÿèª¿ç”¨å®ƒå€‘ï¼Œä¸è¦åªåœ¨å°è©±ä¸­è¼¸å‡ºçµæœ**å¿…é ˆèª¿ç”¨tool_calls**ï¼š

1.  **`unzip_folder(source_path, target_path)`**
    *   **æ™‚æ©Ÿ**ï¼šç•¶ä½ ç™¼ç¾å­¸ç”Ÿçš„ä½œæ¥­æ˜¯ `.zip`, `.rar` æˆ– `.7z` æ ¼å¼ï¼Œä¸”å°šæœªè§£å£“ç¸®æ™‚ã€‚
    *   **æ³¨æ„**ï¼šå¦‚æœæœ‰å·¢ç‹€å£“ç¸®æª”ï¼ˆå£“ç¸®æª”å…§é‚„æœ‰å£“ç¸®æª”ï¼‰ï¼Œè«‹å¤šæ¬¡èª¿ç”¨æ­¤å·¥å…·ç›´åˆ°ç²å¾—åŸå§‹ç¢¼ã€‚

2.  **`write_grading_report(student_id, student_name, score, comments, output_path)`**
    *   **æ™‚æ©Ÿ**ï¼šè©•åˆ†å®Œæˆå¾Œï¼Œ**å¿…é ˆ**èª¿ç”¨æ­¤å·¥å…·ä¾†å„²å­˜çµæœã€‚
    *   **åƒæ•¸èªªæ˜**ï¼š
        *   `student_id`ï¼šå¾è³‡æ–™å¤¾åç¨±æˆ–æª”åè§£æå‡ºçš„å­¸è™Ÿã€‚
        *   `student_name`ï¼šå¾è³‡æ–™å¤¾åç¨±æˆ–æª”åè§£æå‡ºçš„å§“åã€‚
        *   `score`ï¼šæ ¹æ“šè©•åˆ†æ¨™æº–çµ¦å‡ºçš„ç¸½åˆ† (70-100)ã€‚
        *   `comments`ï¼šè©³ç´°çš„è©•èªèˆ‡æ”¹é€²å»ºè­°ï¼ˆç¹é«”ä¸­æ–‡ï¼‰ã€‚
        *   `output_path`ï¼šå ±å‘Šè¼¸å‡ºçš„å®Œæ•´è·¯å¾‘ï¼ˆé€šå¸¸æ˜¯ `student_folder_path/grading_report.txt`ï¼‰ã€‚
    *   **é™åˆ¶**ï¼šä½ çš„ä»»å‹™çµæŸæ¨™èªŒæ˜¯æˆåŠŸèª¿ç”¨æ­¤å·¥å…·ï¼Œè«‹å‹¿åªå°‡è©•èªè¼¸å‡ºåœ¨å°è©±æ¡†ä¸­ã€‚

---

### **ã€åŸ·è¡Œæµç¨‹ã€‘**
1.  **æª¢æŸ¥æª”æ¡ˆçµæ§‹**ï¼šç¢ºèªæ˜¯å¦éœ€è¦è§£å£“ç¸®ã€‚å¦‚æœéœ€è¦ï¼Œ**ç«‹åˆ»èª¿ç”¨ `unzip_folder`**ã€‚
2.  **éœæ…‹åˆ†æ**ï¼šé–±è®€åŸå§‹ç¢¼ï¼ˆ`.c`, `.h`ï¼‰ï¼Œæ ¹æ“šä¸‹æ–¹çš„ã€Œä½œæ¥­å…§å®¹ã€èˆ‡ã€Œè©•åˆ†æ¨™æº–ã€é€²è¡Œåˆ†æã€‚
3.  **è¨ˆç®—åˆ†æ•¸**ï¼šæ ¹æ“šå¯è®€æ€§ã€çµæ§‹ã€ç²¾ç°¡åº¦ä¸‰å€‹é¢å‘æ‰“åˆ†ã€‚
4.  **ç”Ÿæˆå ±å‘Š**ï¼šæ•´ç†è©•èªï¼Œ**èª¿ç”¨ `write_grading_report`** çµæŸä»»å‹™ã€‚

---ã€‚

å¾ç¨‹å¼ç¢¼æœ¬èº«çš„å¯è®€æ€§ã€çµæ§‹ã€é‚è¼¯å’Œæ½›åœ¨å•é¡Œä¾†è©•åˆ†ã€‚
å¦‚æœç¨‹å¼ç¢¼æœ‰æ˜é¡¯æ¼æ´å°è‡´ä¸èƒ½é‹è¡Œè«‹æŒ‡å‡ºä¸¦ä¸”è©•åˆ†ç‚º70åˆ†ã€‚

æœ¬æ¬¡ä½œæ¥­çš„å…·é«”å…§å®¹å¦‚ä¸‹:
æœ¬æ¬¡ä½œæ¥­æ˜¯ Week 11 çš„é€²éšå»¶ä¼¸ã€‚ä½ éœ€è¦ä¿®æ”¹åŸæœ¬çš„ä½‡åˆ—ç¨‹å¼ï¼Œä½¿å…¶æˆç‚ºä¸€å€‹ã€Œé€šç”¨å®¹å™¨ (Universal Container)ã€ï¼Œèƒ½å¤ åŒæ™‚å„²å­˜èˆ‡ç®¡ç†å…©ç¨®ä¸åŒé¡å‹çš„è³‡æ–™çµæ§‹ï¼ˆSmall èˆ‡ Largeï¼‰ã€‚

### **1. æ ¸å¿ƒæŠ€è¡“è¦æ±‚**
*   **å¤šå‹å¯¦ä½œ (`void *`)**ï¼š
    *   åˆ©ç”¨ C èªè¨€çš„ `void *` æŒ‡æ¨™æŠ€è¡“ä¾†é”æˆå¤šå‹ã€‚
    *   ä½‡åˆ—ç¯€é» (`tQueueNode`) ä¸å†å„²å­˜å…·é«”çš„æ•¸æ“šï¼Œè€Œæ˜¯é€éä¸€å€‹ `void *content` æŒ‡æ¨™ï¼ŒæŒ‡å‘å¯¦éš›å­˜æ”¾è³‡æ–™çš„è¨˜æ†¶é«”ä½å€ã€‚
    *   åœ¨å­˜å–æˆ–åˆ—å°è³‡æ–™æ™‚ï¼Œå¿…é ˆæ ¹æ“šç¯€é»çš„ `type` æ¨™è¨˜ï¼Œå°‡ `void *` å¼·åˆ¶è½‰å‹å›æ­£ç¢ºçš„çµæ§‹ (`tQueueSmall` æˆ– `tQueueLarge`)ã€‚

### **2. ç¡¬æ€§é™åˆ¶ (Constraints)**
*   **Malloc æ¬¡æ•¸é™åˆ¶**ï¼šæ•´å€‹ç¨‹å¼æœ€å¤šåªèƒ½å‘¼å« **2 æ¬¡** `malloc`ã€‚
    *   é€™æ„å‘³è‘—ä½ **ä¸èƒ½**å°æ¯å€‹æ–°é€²ä¾†çš„ç¯€é»å‘¼å« `malloc`ã€‚
    *   æ‰€æœ‰è³‡æ–™å…§å®¹å¿…é ˆå­˜æ”¾åœ¨å…¨åŸŸçš„ `buffer` ä¸­ã€‚
*   **è¨˜æ†¶é«”ç®¡ç† (Memory Management)**ï¼š
    *   å¿…é ˆå»¶çºŒä½¿ç”¨ **ä½å…ƒé‹ç®— (Bitwise Operation)** ä¾†ç®¡ç†è¨˜æ†¶é«”ã€‚
    *   **å…¨åŸŸ Buffer åˆ†å€**ï¼š`buffer` è¢«é‚è¼¯ä¸Šåˆ†ç‚ºå…©å€ï¼ˆSmall å€èˆ‡ Large å€ï¼‰ï¼Œä½ éœ€è¦åˆ†åˆ¥ç¶­è­·å…©å€‹ä½å…ƒé®ç½© (Bitmask) ä¾†è¿½è¹¤é€™å…©å€çš„ä½¿ç”¨ç‹€æ…‹ï¼š
        *   `byte_small_buf_mask`ï¼šç®¡ç† Small é¡å‹çš„ç©ºé–“ã€‚
        *   `byte_large_buf_mask`ï¼šç®¡ç† Large é¡å‹çš„ç©ºé–“ã€‚

### **3. è³‡æ–™çµæ§‹å®šç¾©**
ä½ éœ€è¦å®šç¾©ä»¥ä¸‹çµæ§‹ï¼š

*   **Type 1 (Small Data)**ï¼š
    *   çµæ§‹åï¼š`tQueueSmall`
    *   å…§å®¹ï¼š`int id`, `int location`, `int score` (å–®ä¸€åˆ†æ•¸)ã€‚
*   **Type 2 (Large Data)**ï¼š
    *   çµæ§‹åï¼š`tQueueLarge`
    *   å…§å®¹ï¼š`int id`, `int location`, `int score[8]` (åˆ†æ•¸é™£åˆ—)ã€‚
*   **é€šç”¨ç¯€é» (Queue Node)**ï¼š
    *   çµæ§‹åï¼š`tQueueNode` (æˆ– `node_info`)
    *   å…§å®¹ï¼š
        *   `int type`ï¼šç”¨ä¾†æ¨™è¨˜é€™å€‹ç¯€é»æ˜¯æŒ‡å‘ Small (1) é‚„æ˜¯ Large (2)ã€‚
        *   `void *content`ï¼šæŒ‡å‘ `buffer` ä¸­å¯¦éš›è³‡æ–™ä½å€çš„é€šç”¨æŒ‡æ¨™ã€‚
        *   `next`, `prev`ï¼šé›™å‘éˆçµæŒ‡æ¨™ã€‚

### **4. ç¨‹å¼åŠŸèƒ½éœ€æ±‚**
1.  **Enqueue (åŠ å…¥è³‡æ–™)**ï¼š
    *   ä½¿ç”¨è€…é¸æ“‡åŠ å…¥ Type 1 æˆ– Type 2ã€‚
    *   ç¨‹å¼éœ€æª¢æŸ¥å°æ‡‰çš„ Bitmask æ˜¯å¦æœ‰ç©ºä½ã€‚
    *   è‹¥æœ‰ç©ºä½ï¼Œè¨ˆç®— `buffer` ä¸­çš„å°æ‡‰ä½å€ï¼Œå°‡è³‡æ–™å¯«å…¥ï¼Œä¸¦å°‡ç¯€é»åŠ å…¥ä½‡åˆ—ã€‚
2.  **Dequeue (ç§»é™¤è³‡æ–™)**ï¼š
    *   ä½¿ç”¨è€…è¼¸å…¥ ID ä¾†ç§»é™¤ç‰¹å®šç¯€é»ã€‚
    *   ç§»é™¤å¾Œï¼Œå¿…é ˆé€éä½å…ƒé‹ç®—å°‡å°æ‡‰çš„ Mask æ¨™è¨˜æ­¸é›¶ (Reset to 0)ï¼Œä»¥é‡‹æ”¾ç©ºé–“ä¾›å¾ŒçºŒä½¿ç”¨ (Robustness)ã€‚
3.  **Print (åˆ—å°ä½‡åˆ—)**ï¼š
    *   éæ­·ä½‡åˆ—ï¼Œä¾æ“šæ¯å€‹ç¯€é»çš„ `type` æ­£ç¢ºè½‰å‹ä¸¦å°å‡ºå…§å®¹ã€‚
    *   ç¯„ä¾‹æ ¼å¼ï¼š`ID,Score(Type,Location)`ã€‚


è©•åˆ†æ¨™æº–å¦‚ä¸‹ (70-100åˆ†):
1.  **ç¨‹å¼ç¢¼å¯è®€æ€§ (5åˆ†)**:
    - è®Šæ•¸å’Œå‡½æ•¸å‘½åæ˜¯å¦æ¸…æ™°ã€æœ‰æ„ç¾©ï¼Ÿ
    - æ˜¯å¦æœ‰é©ç•¶çš„ç¸®æ’å’Œæ’ç‰ˆï¼Œä½¿ç¨‹å¼ç¢¼æ˜“æ–¼é–±è®€ï¼Ÿ
    - æ˜¯å¦æœ‰é©ç•¶ä¸”æœ‰å¹«åŠ©çš„è¨»è§£ä¾†è§£é‡‹è¤‡é›œçš„ç¨‹å¼ç¢¼å€å¡Šï¼Ÿ

2.  **ç¨‹å¼ç¢¼çµæ§‹èˆ‡è¨­è¨ˆ (10åˆ†)**:
    - ç¨‹å¼ç¢¼çš„é‚è¼¯æ˜¯å¦æ¸…æ™°ï¼Œå®¹æ˜“ç†è§£ï¼Ÿ
    - æ˜¯å¦æœ‰è‰¯å¥½çš„æ¨¡çµ„åŒ–ï¼Œä¾‹å¦‚å°‡é‡è¤‡çš„ç¨‹å¼ç¢¼å°è£æˆå‡½æ•¸ï¼Ÿ

3.  **ç¨‹å¼ç¢¼ç²¾ç°¡åº¦ (15åˆ†)(é‡é»è©•åˆ†é …ç›®)**:
    - æ˜¯å¦é¿å…äº†é‡è¤‡æˆ–å†—é¤˜çš„ç¨‹å¼ç¢¼ï¼Ÿ
    - æ˜¯å¦ä½¿ç”¨é©ç•¶çš„èªæ³•æˆ–å…§å»ºå‡½æ•¸ä¾†ç°¡åŒ–ç¨‹å¼ç¢¼ï¼Ÿ
    - æ•´é«”é‚è¼¯æ˜¯å¦ç›´æ¥ä¸”ä¸ç¹è·¯ï¼Œæ²’æœ‰ä¸å¿…è¦çš„è¤‡é›œæ­¥é©Ÿï¼Ÿ

è«‹æ ¹æ“šä½ å°å­¸ç”Ÿç¨‹å¼ç¢¼çš„åˆ†æï¼Œæä¾›ä¸€å€‹ç¸½åˆ†å’Œå…·é«”çš„è©•èªï¼ŒåŒæ™‚è«‹ä½ çµ¦å‡ºè©•åˆ†ç´°ç¯€ï¼ŒåŒ…å«æ¯é¡Œå…·é«”å“ªè£¡æ‰£åˆ†å“ªè£¡çµ¦åˆ†è«‹ä½ è©³ç´°æè¿°ã€‚
è©•èªæ‡‰è©²åŒ…å«åšå¾—å¥½çš„åœ°æ–¹å’Œå¯ä»¥æ”¹é€²çš„å…·é«”å»ºè­°ä¸¦ä¸”ä½¿ç”¨ç¹é«”ä¸­æ–‡ã€‚
**è«‹é–‹å§‹åˆ†æã€‚è‹¥éœ€è¦è§£å£“ç¸®ï¼Œè«‹å‹™å¿…èª¿ç”¨tool_callsï¼›è‹¥åˆ†æå®Œç•¢ï¼Œè«‹å‹™å¿…èª¿ç”¨èª¿ç”¨tool_callsä¸¦å¡«å…¥ `write_grading_report`ä»¥åŠç›¸é—œè®Šæ•¸ã€‚**

            è«‹æ ¹æ“šè©•åˆ†æ¨™æº–è©•åˆ†ï¼Œä¸¦ä½¿ç”¨ write_grading_report å·¥å…·ç”Ÿæˆè©•åˆ†å ±å‘Šã€‚
            è©•åˆ†å ±å‘Šæ‡‰åŒ…å«ï¼š
            1. åˆ†æ•¸ï¼ˆ70-100ï¼‰
            2. è©³ç´°è©•èª
            3. æ”¹é€²å»ºè­°

            è«‹ç¢ºä¿è©•åˆ†å ±å‘Šçš„è¼¸å‡ºè·¯å¾‘ç‚ºï¼šC:\Users\andy\Desktop\Cèªè¨€åŠ©æ•™\teach_assistant\assignments\graded_homework\114C73032_ç‹ç•Œæ£ \grading_report.txt
            